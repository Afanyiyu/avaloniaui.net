Title: Avalonia 0.9.0 Release
Published: 2019-12-13
Category: Release
Author: Dan Walmsley
---

We are pleased to announce that [Avalonia](https://github.com/AvaloniaUI/Avalonia) 0.9.0 has been
released.

0.9 is a huge update, it has been extensively tested and brings some great new features and improvements.


# Compiled XAML
In previous releases XAML was parsed at runtime. This meant that some syntax errors could cause runtime crashes, and may be hard to identify.

Now we have a scratch built XAML compiler that parses all the XAML at build time, and converts it directly to MSIL.

This gives incredibly improved runtime performance, application startup times and developers will get syntax errors at build time.

This also allows debugging of XAML code, where you can step through XAML as your application runs.

# OSX / Linux Native Menus
In order for Avalonia applications to feel properly at home on OSX we have implemented the apis to allow native menu integration.

OSX places a menu that is permanently at the top of the screen. The first item of which the title matched the application name, is a global application menu, and is displayed regardless of the selected window or if the application is minimised.

Avalonia will now create this menu for you, and generate the standard menu items.
![OSXAppMenu](/blog/2019-12-13-avalonia-0.9.0-release/osx-app-menu.png)

If you want to customise this menu, then you can do so by declaring a Native Menu in your Application.xaml file like so.

```xml
<Application>
  <NativeMenu.Menu>
    <NativeMenu>
      <NativeMenuItem Header="About MyApp" Command="{Binding AboutCommand}" />
    </NativeMenu>
  </NativeMenu.Menu>
</Application>
```

The consequence of this is that the Application class now has a DataContext property, where you can assign a ViewModel and bind to properties, just like any other control in Avalonia.

The Window menus of course are window specific, and can be declared like:

```xml
<NativeMenu.Menu>
    <NativeMenu>
      <NativeMenuItem Header="File">
        <NativeMenuItem.Menu>
          <NativeMenu>
            <NativeMenuItem Header="Open" Command="{Binding OpenCommand}"/>
            <NativeMenuItemSeperator/>
            <NativeMenuItem Header="Recent">
              <NativeMenuItem.Menu>
                <NativeMenu/>
              </NativeMenuItem.Menu>
            </NativeMenuItem>
            <NativeMenuItemSeperator/>
            <NativeMenuItem Header="Quit Avalonia" Command="{Binding CloseCommand}" Gesture="CMD+Q"/>
          </NativeMenu>
        </NativeMenuItem.Menu>
      </NativeMenuItem>
      <NativeMenuItem Header="Edit">
        <NativeMenuItem.Menu>
          <NativeMenu>
            <NativeMenuItem Header="Copy"/>
            <NativeMenuItem Header="Paste"/>
          </NativeMenu>
        </NativeMenuItem.Menu>
      </NativeMenuItem>
    </NativeMenu>
  </NativeMenu.Menu>
```

As you can see, native menus support gestures just like a normal MenuItem would.

![OSXWindowMenu](/blog/2019-12-13-avalonia-0.9.0-release/osx-window-menu.png)


# Optional Managed File Dialogs
Some operating systems may not have their own File dialogs, or you may prefer to use Avalonia own file dialog for consistent UI.

![ManagedDialogs](/blog/2019-12-13-avalonia-0.9.0-release/managed-file-dialog.png)

You can configure Avalonia to use the managed dialog by adding to the appbuilder like so:

```csharp
AppBuilder.Configure<App>()
.UsePlatformDetect()
.UseManagedSystemDialogs();
```

If you wish the file dialog to be hosted inside your own window, where you control the chrome, colour scheme, title, icon, etc you can also use...

```csharp
.UseManagedSystemDialogs<AppBuilder, MyCustomWindowType>();
```

# ItemsRepeater
The ItemsRepeater control has been ported from UWP. This gives very high performance when displaying very long lists.

# New Grid and GridSplitter
Now that WPF has been opensourced we have directly ported Grid and Grid Splitter from those repositories. This means you can now expect 100% identical behavior of these fundamental controls.

# Performance Improvements
Its worth mentioning that there have been many improvements to Avalonia especially to improve performance, reducing the amount of memory and improving speed. Many projects are now able to run smoothly on embedded platforms like Raspberry PI for instance.

# Production Ready
Many people come and ask, is Avalonia production ready? The answer is YES!
There are now several applications built on Avalonia with quite large user bases. We see all the time many commercial products that are now porting to Avalonia.

The teams behinds these projects have been involved with testing this release.

For this reason we will be maintaining a branch of the 0.9 release with only bug fixes. So 0.9 will be maintained and supported even as we start the development of the next major version of Avalonia.
 
 # Getting started

Follow instructions [here](/docs/quickstart).

# Special Thanks
This release has only been possible due to the dedicated work of many people, notably
[grokys](https://github.com/grokys), [jkoritzinsky](https://github.com/jkoritzinsky), [kekekeks](https://github.com/kekekeks), [jmacato](https://github.com/jmacato), [marchingcube](https://github.com/marchingcube), [wieslawsoltes](https://github.com/wieslawsoltes), [gillibald](https://github.com/gillibald) and many others.

The best way to support Avalonia is to get involved, implement a feature, fix a bug or help test. See [contributing](http://avaloniaui.net/contributing/contributing) for information on how to get started.

Otherwise you can sponsor Avalonia financially via [OpenCollective](https://opencollective.com/Avalonia#sponsor).


We hope you enjoy developing with Avalonia please let us know what you are building.

[danwalmsley](https://github.com/danwalmsley)
